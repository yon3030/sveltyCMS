import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import type { RequestHandler } from './$types';

export const POST: RequestHandler = async ({ request }) => {
	// Get the data from the request body
	let data = await request.json();

	// If data is undefined, return an error response
	if (!data) {
		return new Response('No data provided', { status: 400 });
	}

	// Define the path to the config.ts file
	const configFilePath = path.join(process.cwd(), 'src', 'collections', 'config.ts');

	// map data
	data = data.map((category: any) => {
		const newData = {
			...category,
			collections: category.items.map((item: any) => {
				return `|||collections.${item.name}|||`;
			})
		};
		delete newData.id;
		delete newData.items;
		return newData;
	});

	// Define the new content of the config.ts file
	let newConfigFileContent = `// Configure how Collections are sorted & displayed in Categories section.
  // This file is generated by the updateConfig API and will be recreated if altered in GUI

  export function createCategories(collections: any) {return ${JSON.stringify(data, null, 2)};}
  `;

	newConfigFileContent = newConfigFileContent.replace(/"\|\|\|/g, '').replace(/\|\|\|"/g, '');

	try {
		// Check if the config file exists and read its content
		let existingContent = '';
		try {
			existingContent = await fs.readFile(configFilePath, 'utf8');
		} catch (readError) {
			// If the file doesn't exist, proceed with writing the new content
		}

		// Create a hash of the new config content
		const newContentHash = crypto.createHash('md5').update(newConfigFileContent).digest('hex');

		// Create a hash of the existing config content if it exists
		const existingContentHash = existingContent ? crypto.createHash('md5').update(existingContent).digest('hex') : '';

		// Compare hashes to determine if the file needs to be updated
		if (newContentHash !== existingContentHash) {
			// Write the new content to the config.ts file asynchronously
			await fs.writeFile(configFilePath, newConfigFileContent);
			// Return a success response
			return new Response('Config file updated successfully by API', { status: 200 });
		} else {
			// Return a response indicating no update was necessary
			return new Response('No changes detected, config file not updated', { status: 304 });
		}
	} catch (error: any) {
		console.error(error);
		// Instead of returning a Response object with a 500 status code, return a plain text response
		return {
			status: 500,
			body: `Error updating config file: ${error.message}`
		};
	}
};
